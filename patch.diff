diff --git a/LR_Modules/dfpt_tetra_mod.f90 b/LR_Modules/dfpt_tetra_mod.f90
index d341ff695..ec1dfd4b5 100644
--- a/LR_Modules/dfpt_tetra_mod.f90
+++ b/LR_Modules/dfpt_tetra_mod.f90
@@ -18,7 +18,10 @@ MODULE dfpt_tetra_mod
   !
   PRIVATE
   PUBLIC :: dfpt_tetra_beta, dfpt_tetra_ttheta, dfpt_tetra_delta, &
-            dfpt_tetra_main, dfpt_tetra_linit
+  &         dfpt_tetra_main, dfpt_tetra_linit, &
+  &         dfpt_tetra_lindhard_1234, dfpt_tetra_lindhard_1231, &
+  &         dfpt_tetra_lindhard_1233, dfpt_tetra_lindhard_1221, &
+  &         dfpt_tetra_lindhard_1222, dfpt_tetra_lindhard_1211
   !
   LOGICAL,SAVE :: dfpt_tetra_linit = .FALSE.
   !
@@ -1525,12 +1528,13 @@ SUBROUTINE dfpt_tetra_lindhard(ei,ej,w)
   call hpsort (4, e, itetra)
   !
   thr = MAXVAL(e(1:4)) * 1e-3_dp
-  thr2 = 1e-8_dp
+  thr2 = 1e-10_dp
   !
   DO ii = 1, 4
      IF(e(ii) < thr2) THEN
         IF(ii == 3) THEN
-           CALL errore("dfpt_tetra_lindhard", "Nesting occurs.", 0)
+           write(*,*) e(1:4)
+           CALL errore("dfpt_tetra_lindhard", "Nesting occurs.", 1)
         END IF
         le(ii) = 0.0_dp
         e(ii) = 0.0_dp
@@ -1562,7 +1566,7 @@ SUBROUTINE dfpt_tetra_lindhard(ei,ej,w)
            IF(ANY(w(itetra(1:4)) < 0.0_dp)) THEN
               WRITE(*,'(100e15.5)') e(1:4)
               WRITE(*,'(100e15.5)') w(itetra(1:4))
-              CALL errore("dfpt_tetra_lindhard", "4=3=2", 0)
+              CALL errore("dfpt_tetra_lindhard", "Case : 4=3=2", 1)
            END IF
            !
         END IF
@@ -1578,7 +1582,7 @@ SUBROUTINE dfpt_tetra_lindhard(ei,ej,w)
         IF(ANY(w(itetra(1:4)) < 0.0_dp)) THEN
            WRITE(*,'(100e15.5)') e(1:4)
            WRITE(*,'(100e15.5)') w(itetra(1:4))
-           CALL errore("dfpt_tetra_lindhard", "4=3 2=1", 0)
+           CALL errore("dfpt_tetra_lindhard", "Case : 4=3, 2=1", 1)
         END IF
         !
      ELSE
@@ -1593,7 +1597,7 @@ SUBROUTINE dfpt_tetra_lindhard(ei,ej,w)
         IF(ANY(w(itetra(1:4)) < 0.0_dp)) THEN
            WRITE(*,'(100e15.5)') e(1:4)
            WRITE(*,'(100e15.5)') w(itetra(1:4))
-           CALL errore("dfpt_tetra_lindhard", "4=3", 0)
+           CALL errore("dfpt_tetra_lindhard", "Case : 4=3", 1)
         END IF
         !
      END IF
@@ -1610,7 +1614,7 @@ SUBROUTINE dfpt_tetra_lindhard(ei,ej,w)
         IF(ANY(w(itetra(1:4)) < 0.0_dp)) THEN
            WRITE(*,'(100e15.5)') e(1:4)
            WRITE(*,'(100e15.5)') w(itetra(1:4))
-           CALL errore("dfpt_tetra_lindhard", "3=2=1", 0)
+           CALL errore("dfpt_tetra_lindhard", "Case : 3=2=1", 1)
         END IF
         !
      ELSE
@@ -1625,7 +1629,7 @@ SUBROUTINE dfpt_tetra_lindhard(ei,ej,w)
         IF(ANY(w(itetra(1:4)) < 0.0_dp)) THEN
            WRITE(*,'(100e15.5)') e(1:4)
            WRITE(*,'(100e15.5)') w(itetra(1:4))
-           CALL errore("dfpt_tetra_lindhard", "3=2", 0)
+           CALL errore("dfpt_tetra_lindhard", "Case : 3=2", 1)
         END IF
         !
      END IF
@@ -1641,12 +1645,12 @@ SUBROUTINE dfpt_tetra_lindhard(ei,ej,w)
      IF(ANY(w(itetra(1:4)) < 0.0_dp)) THEN
         WRITE(*,'(100e15.5)') e(1:4)
         WRITE(*,'(100e15.5)') w(itetra(1:4))
-        CALL errore("dfpt_tetra_lindhard", "2=1", 0)
+        CALL errore("dfpt_tetra_lindhard", "Case : 2=1", 1)
      END IF
      !
   ELSE
      !
-     ! DIFferent each other.
+     ! Different each other.
      !
      w(itetra(4)) = dfpt_tetra_lindhard_1234(e(4),e(1),e(2),e(3),le(4),le(1),le(2),le(3))
      w(itetra(3)) = dfpt_tetra_lindhard_1234(e(3),e(1),e(2),e(4),le(3),le(1),le(2),le(4))
@@ -1656,7 +1660,7 @@ SUBROUTINE dfpt_tetra_lindhard(ei,ej,w)
      IF(ANY(w(itetra(1:4)) < 0.0_dp)) THEN
         WRITE(*,'(100e15.5)') e(1:4)
         WRITE(*,'(100e15.5)') w(itetra(1:4))
-        CALL errore("dfpt_tetra_lindhard", "Something wrong.", 0)
+        CALL errore("dfpt_tetra_lindhard", "Case : Different each other", 1)
      END IF
      !
   END IF
diff --git a/LR_Modules/setup_nscf.f90 b/LR_Modules/setup_nscf.f90
index e9df8ba14..bf189a9ab 100644
--- a/LR_Modules/setup_nscf.f90
+++ b/LR_Modules/setup_nscf.f90
@@ -49,6 +49,7 @@ SUBROUTINE setup_nscf ( newgrid, xq, elph_mat )
   LOGICAL, INTENT (IN) :: newgrid
   LOGICAL, INTENT (IN) :: elph_mat  ! used to be passed through a module. 
   !
+  INTEGER :: t_rev_dummy(48)
   INTEGER  :: t_rev_eff(48), ik
   LOGICAL  :: magnetic_sym, sym(48)
   LOGICAL  :: skip_equivalence
@@ -143,8 +144,14 @@ SUBROUTINE setup_nscf ( newgrid, xq, elph_mat )
   !
   IF ( ltetra .AND. (tetra_type /= 0) ) THEN
      IF (ALLOCATED(tetra)) DEALLOCATE(tetra)
-     CALL opt_tetra_init(nsymq, s, time_reversal .AND. minus_q, t_rev, at, bg,&
-          npk, k1, k2, k3, nk1, nk2, nk3, nkstot, xk, kunit)
+     IF(elph_mat) THEN
+        t_rev_dummy(1:48) = 0
+        CALL opt_tetra_init(1, s, .FALSE., t_rev_dummy, at, bg,&
+             npk, k1, k2, k3, nk1, nk2, nk3, nkstot, xk, kunit)
+     ELSE
+        CALL opt_tetra_init(nsymq, s, time_reversal .AND. minus_q, t_rev, at, bg,&
+        npk, k1, k2, k3, nk1, nk2, nk3, nkstot, xk, kunit)
+     END IF
   END IF
   !
   IF ( lsda ) THEN
diff --git a/Makefile b/Makefile
index c7183c202..2d6be5fc9 100644
--- a/Makefile
+++ b/Makefile
@@ -33,6 +33,7 @@ default :
 	@echo '  xspectra     X-ray core-hole spectroscopy calculations'
 	@echo '  couple       Library interface for coupling to external codes'
 	@echo '  epw          Electron-Phonon Coupling with Wannier functions'
+	@echo '  sctk         SCDFT code'
 	@echo '  kcw          KCW code: implementation of Koopmans functionals in primitive cell'
 	@echo '  gui          Graphical User Interface'
 	@echo '  all          same as "make pwall cp ld1 tddfpt xspectra hp"'
@@ -130,6 +131,11 @@ epw: phlibs w90lib pp
 	( cd EPW ; $(MAKE) all || exit 1; \
 		cd ../bin; ln -fs ../EPW/bin/epw.x . ); fi
 
+sctk: ph pp
+	if test -d SCTK ; then \
+	( cd SCTK ; $(MAKE) all || exit 1; \
+		cd ../bin; ln -fs ../SCTK/src/sctk.x . ); fi
+
 all_currents:
 	if test -d QEHeat ; then \
 	( cd QEHeat ; $(MAKE) all || exit 1; ) ; fi
@@ -294,7 +300,7 @@ clean :
 		CPV LAXlib FFTXlib XClib UtilXlib upflib Modules PP PW EPW KS_Solvers \
 		NEB ACFDT COUPLE GWW XSpectra PWCOND dft-d3 \
 		atomic LR_Modules upflib \
-		dev-tools extlibs Environ TDDFPT PHonon HP GWW Doc GUI \
+		dev-tools extlibs Environ TDDFPT PHonon HP GWW Doc GUI SCTK \
 		QEHeat KCW \
 	; do \
 	    if test -d $$dir ; then \
diff --git a/PHonon/PH/alpha2f.f90 b/PHonon/PH/alpha2f.f90
index 099af46f0..0516fee64 100644
--- a/PHonon/PH/alpha2f.f90
+++ b/PHonon/PH/alpha2f.f90
@@ -21,6 +21,10 @@ MODULE alpha2f_vals
   !
   INTEGER :: nfreq
   !
+  REAL(DP),SAVE :: &
+  & freq_min, &
+  & freq_min_ratio
+  !
   REAL(DP),ALLOCATABLE,SAVE :: &
   & omg(:,:), & ! (nmodes,nqs) Phonon frequencies on irreducible q
   & lam(:,:), & ! (nmodes,nqs) El-Ph coupling  on irreducible q
@@ -145,11 +149,10 @@ SUBROUTINE read_lam()
   !
   USE kinds,     ONLY : DP
   USE disp,      ONLY : nqs, x_q
-  USE cell_base, ONLY : at
   USE modes,     ONLY : nmodes
   USE output,    ONLY : fildyn
   !
-  USE alpha2f_vals, ONLY : omg, lam
+  USE alpha2f_vals, ONLY : omg, lam, freq_min, freq_min_ratio
   !
   IMPLICIT NONE
   !
@@ -184,17 +187,20 @@ SUBROUTINE read_lam()
      !
      DO im = 1, nmodes
         READ(fi,'(a19,f8.4)') ctmp, lam(im,iq)
-        IF (omg(im,iq) > 0.0_dp) THEN
-           omg(im,iq) = SQRT(omg(im,iq))
-        ELSE
-           CALL errore ('read_lam', "Imaginary frequency", iq )
-        END IF
      END DO
      !
      CLOSE(fi)
      !
   END DO
   !
+  ! w^2 (input) -> w
+  !
+  omg(1:nmodes,1:nqs) = sign(SQRT(ABS(omg(1:nmodes,1:nqs))), omg(1:nmodes,1:nqs))
+  !
+  IF(freq_min_ratio > 0.0) THEN
+     freq_min = freq_min_ratio * MAXVAL(omg(1:nmodes,1:nqs))
+  END IF
+  !
 END SUBROUTINE read_lam
 !
 !-------------------------------------------------------------------
@@ -205,7 +211,7 @@ SUBROUTINE compute_a2F()
   USE kinds,     ONLY : DP
   USE ions_base, ONLY : nat
   USE modes,     ONLY : nmodes
-  USE ktetra,    ONLY : ntetra, tetra, opt_tetra_init, opt_tetra_partialdos
+  USE ktetra,    ONLY : ntetra, opt_tetra_init, opt_tetra_partialdos
   USE wvfct,     ONLY : et, nbnd
   USE io_global, ONLY : stdout
   USE cell_base, ONLY : at, bg
@@ -302,15 +308,15 @@ SUBROUTINE compute_lambda()
   USE modes,     ONLY : nmodes  
   USE constants, ONLY : RY_TO_THZ, K_BOLTZMANN_RY
   USE ktetra,    ONLY : ntetra, wlsm, tetra
-  USE disp,      ONLY : nqs
+  USE disp,      ONLY : nqs, x_q
   USE io_global, ONLY : stdout
   USE io_files,  ONLY : prefix
   !
-  USE alpha2f_vals, ONLY : omg, lam
+  USE alpha2f_vals, ONLY : omg, lam, freq_min
   !
   IMPLICIT NONE
   !
-  INTEGER :: ii, itetra, iq, fo
+  INTEGER :: ii, itetra, iq, fo, imode
   REAL(DP) :: omglog, lambda, wq(nqs)
   !
   INTEGER, EXTERNAL :: find_free_unit
@@ -326,8 +332,15 @@ SUBROUTINE compute_lambda()
   lambda = 0.0_dp
   omglog = 0.0_dp
   DO iq = 1, nqs
-     lambda = lambda + wq(iq) * SUM(lam(1:nmodes, iq))
-     omglog = omglog + wq(iq) * SUM(LOG(omg(1:nmodes,iq)) * lam(1:nmodes,iq))
+     DO imode = 1, nmodes
+        IF(omg(imode, iq) > freq_min) THEN
+           lambda = lambda + wq(iq) * lam(imode, iq)
+           omglog = omglog + wq(iq) * LOG(omg(imode,iq)) * lam(imode,iq)
+        ELSE
+           WRITE(stdout,'(a,i0,a,i0,a,3f10.5,a,e15.5)') &
+           & "IGNORE iq=", iq, ", imode=", imode, ", x_q=", x_q(1:3,iq), ", omega[THz]=", omg(imode,iq)*RY_TO_THZ
+        END IF
+     END DO
   END DO
   omglog = omglog / lambda
   omglog = EXP(omglog)
@@ -371,23 +384,24 @@ PROGRAM alpha2f
   !! This routine reads lambda*.dat and compute a^2F, phonon DOS, lambda,
   !! & omega_ln.
   !
+  USE kinds,          ONLY : DP
   USE mp_global,      ONLY : mp_startup, mp_global_end
   USE environment,    ONLY : environment_start, environment_end
   USE elph_tetra_mod, ONLY : in_alpha2f
   USE io_global,      ONLY : qestdin, ionode
   USE modes,          ONLY : nmodes
   USE ions_base,      ONLY : nat
+  USE constants,      ONLY : RY_TO_THZ
   USE mp_world,       ONLY : nproc
   !
-  USE alpha2f_vals,     ONLY : nfreq
+  USE alpha2f_vals,     ONLY : nfreq, freq_min, freq_min_ratio
   USE alpha2f_routines, ONLY : read_lam, compute_a2f, compute_lambda, read_polarization
   !
   implicit none
   !
   CHARACTER (LEN=256) :: auxdyn
-  INTEGER :: ios
   !
-  NAMELIST /INPUTA2F/ nfreq
+  NAMELIST /INPUTA2F/ nfreq, freq_min, freq_min_ratio
   !
   CALL mp_startup()
   !
@@ -399,7 +413,11 @@ PROGRAM alpha2f
   CALL phq_readin()
   nmodes = 3 * nat
   !
+  nfreq = 100
+  freq_min = 0.0_dp
+  freq_min_ratio = -1.0
   IF(ionode) READ( qestdin, INPUTA2F )
+  freq_min = freq_min / RY_TO_THZ
   !
   CALL check_initial_status(auxdyn)
   !
diff --git a/PHonon/PH/do_q2r.f90 b/PHonon/PH/do_q2r.f90
index 9b8684a91..9fc7f1598 100644
--- a/PHonon/PH/do_q2r.f90
+++ b/PHonon/PH/do_q2r.f90
@@ -5,6 +5,131 @@
 ! in the root directory of the present distribution,
 ! or http://www.gnu.org/copyleft/gpl.txt .
 !
+MODULE half_q_shift
+  !
+  PRIVATE
+  PUBLIC q_shift_phase
+  !
+  CONTAINS
+  !
+SUBROUTINE q_shift_phase(nr1,nr2,nr3,nat,at,tau,ifc)
+  !-------------------------------------
+  !! Phase for shifted q-grid
+  !
+  ! C(R) = sum_q exp(2*pi*i*(q+0.5)*R/N) C(q+0.5)
+  !      = exp(pi*i*R/N) sum_q exp(2*pi*i*q*R/N) C(q+0.5)
+  !
+  USE kinds, ONLY : DP
+  USE constants,   ONLY : pi
+  !
+  IMPLICIT NONE
+  !
+  INTEGER,INTENT(IN) :: nat
+  INTEGER,INTENT(INOUT) :: nr1, nr2, nr3
+  REAL(DP),INTENT(IN) :: at(3,3), tau(3,nat)
+  COMPLEX(DP),ALLOCATABLE,INTENT(INOUT) :: ifc(:,:,:,:,:)
+  !
+  INTEGER, PARAMETER:: nrwsx=200
+  INTEGER :: i1, i2, i3, nrws, n_low(3), n_up(3), ia, ja, n_old(3), n_new(3), &
+  &          nr1_old, nr2_old, nr3_old, nshift_q
+  REAL(DP) :: qshift_phase, atws(3,3), rws(0:3,nrwsx), r_ws(3)
+  REAL(DP), EXTERNAL :: wsweight
+  COMPLEX(DP) :: qshift_coef(3)
+  COMPLEX(DP),ALLOCATABLE :: ifc2(:,:,:,:,:)
+  !
+  ALLOCATE(ifc2(nr1*nr2*nr3,3,3,nat,nat))
+  !
+  DO i3 = 0, nr3 - 1
+     !
+     qshift_phase = pi * REAL(i3,DP) / REAL(nr3,DP)
+     qshift_coef(3) = CMPLX(COS(qshift_phase), SIN(qshift_phase), kind=DP)
+     !
+     DO i2 = 0, nr2 - 1
+        !
+        qshift_phase = pi * REAL(i2,DP) / REAL(nr2,DP)
+        qshift_coef(2) = CMPLX(COS(qshift_phase), SIN(qshift_phase), kind=DP)
+        !
+        DO i1 = 0, nr1 - 1
+           !
+           qshift_phase = pi * REAL(i1,DP) / REAL(nr1,DP)
+           qshift_coef(1) = CMPLX(COS(qshift_phase), SIN(qshift_phase), kind=DP)
+           !
+           ifc2(   1+i1+nr1*i2+nr1*nr2*i3,1:3,1:3,1:nat,1:nat) &
+           & = ifc(1+i1+nr1*i2+nr1*nr2*i3,1:3,1:3,1:nat,1:nat) * PRODUCT(qshift_coef(1:3))
+           !
+        END DO
+     END DO
+  END DO
+  !
+  atws(1:3,1) = at(1:3,1) * REAL(nr1, DP)
+  atws(1:3,2) = at(1:3,2) * REAL(nr2, DP)
+  atws(1:3,3) = at(1:3,3) * REAL(nr3, DP)
+  CALL wsinit(rws,nrwsx,nrws,atws)
+  !
+  n_low(1:3) = 0
+  n_up( 1:3) = 0
+  DO ia = 1, nat
+     DO ja = 1, nat
+        DO i3 = -2*nr3, 2*nr3
+           DO i2 = -2*nr2, 2*nr2
+              DO i1 = -2*nr1, 2*nr1
+                 r_ws(1:3) = MATMUL(at(1:3,1:3), REAL((/i1,i2,i3/),DP))
+                 r_ws(1:3) = r_ws(1:3) + tau(1:3,ja)-tau(1:3,ia)
+                 IF(wsweight(r_ws,rws,nrws) > 1.0e-8_dp) THEN
+                    n_low(1) = MIN(n_low(1), i1)
+                    n_low(2) = MIN(n_low(2), i2)
+                    n_low(3) = MIN(n_low(3), i3)
+                    n_up( 1) = MAX(n_up( 1), i1)
+                    n_up( 2) = MAX(n_up( 2), i2)
+                    n_up( 3) = MAX(n_up( 3), i3)
+                 END IF
+              END DO
+           END DO
+        END DO
+     END DO
+  END DO
+  !
+  nr1_old = nr1
+  nr2_old = nr2
+  nr3_old = nr3
+  !
+  nr1 = 1+n_up(1)-n_low(1)
+  nr2 = 1+n_up(2)-n_low(2)
+  nr3 = 1+n_up(3)-n_low(3)
+  DEALLOCATE(ifc)
+  ALLOCATE(ifc(nr1*nr2*nr3,3,3,nat,nat))
+  ifc(1:nr1*nr2*nr3,1:3,1:3,1:nat,1:nat) = 0.0_dp
+  !
+  DO ia = 1, nat
+     DO ja = 1, nat
+        DO i1 = n_low(1), n_up(1)
+           DO i2 = n_low(2), n_up(2)
+              DO i3 = n_low(3), n_up(3)
+                 r_ws(1:3) = MATMUL(at(1:3,1:3), REAL((/i1,i2,i3/),DP))
+                 r_ws(1:3) = r_ws(1:3) + tau(1:3,ja)-tau(1:3,ia)
+                 !
+                 IF(wsweight(r_ws,rws,nrws) > 1.0e-8_dp) THEN
+                    n_old(1:3) = MODULO((/i1,i2,i3/), (/nr1_old,nr2_old,nr3_old/))
+                    n_new(1:3) = MODULO((/i1,i2,i3/), (/nr1,    nr2,    nr3    /))
+                    nshift_q = (i1-n_old(1))/nr1_old + (i2-n_old(2))/nr2_old + (i3-n_old(3))/nr3_old
+                    !
+                    ifc(   1+n_new(1)+nr1    *n_new(2)+nr1    *nr2    *n_new(3),1:3,1:3,ja,ia) = &
+                    & ifc2(1+n_old(1)+nr1_old*n_old(2)+nr1_old*nr2_old*n_old(3),1:3,1:3,ja,ia) &
+                    & *wsweight(r_ws,rws,nrws)*(-1.0_dp)**nshift_q
+                 END IF
+                 !
+              END DO
+           END DO
+        END DO
+     END DO
+  END DO
+  !
+  DEALLOCATE(ifc2)
+  !
+END SUBROUTINE q_shift_phase
+!
+END MODULE half_q_shift
+!
 !-----------------------------------------------------------------------
 SUBROUTINE do_q2r(fildyn_, flfrc, prefix, zasr, la2F, loto_2d, write_lr)
   !-----------------------------------------------------------------------
@@ -25,6 +150,8 @@ SUBROUTINE do_q2r(fildyn_, flfrc, prefix, zasr, la2F, loto_2d, write_lr)
   USE environment, ONLY : environment_start, environment_end
   USE rigid,       ONLY : rgd_blk
   USE el_phon,     ONLY : el_ph_nsigma
+  USE elph_tetra_mod, ONLY : lshift_q
+  USE half_q_shift, ONLY : q_shift_phase
   !
   IMPLICIT NONE
   !
@@ -236,13 +363,20 @@ SUBROUTINE do_q2r(fildyn_, flfrc, prefix, zasr, la2F, loto_2d, write_lr)
            DO icar=1,3
               xq = xq + at(icar,ipol) * q(icar,nq) * nr(ipol)
            END DO
+           IF(lshift_q) xq = xq - 0.5_dp
            lq = lq .AND. (ABS(NINT(xq) - xq) .LT. eps)
            iq = NINT(xq)
            !
            m(ipol)= MOD(iq,nr(ipol)) + 1
            IF (m(ipol) .LT. 1) m(ipol) = m(ipol) + nr(ipol)
         END DO
-        IF (.NOT.lq) CALL errore('init','q not allowed',1)
+        IF (.NOT.lq) THEN
+           IF(lshift_q) THEN
+              CYCLE
+           ELSE
+              CALL errore('init','q not allowed',1)
+           END IF
+        END IF
         
         IF(nc(m(1),m(2),m(3)).EQ.0) THEN
            nc(m(1),m(2),m(3))=1
@@ -310,6 +444,8 @@ SUBROUTINE do_q2r(fildyn_, flfrc, prefix, zasr, la2F, loto_2d, write_lr)
      END DO
   END IF
   !
+  IF(lshift_q) CALL q_shift_phase(nr1,nr2,nr3,nat,at,tau,phid)
+  !
   ! Real space force constants written to file (analytical part)
   !
   IF (xmldyn) THEN
@@ -381,6 +517,12 @@ SUBROUTINE do_q2r(fildyn_, flfrc, prefix, zasr, la2F, loto_2d, write_lr)
      WRITE (stdout,"(/5x,' fft-check success (sum of imaginary terms < 10^-12)')")
   END IF
   !
+  IF(lshift_q) THEN
+     nr1 = nr(1)
+     nr2 = nr(2)
+     nr3 = nr(3)
+  END IF
+  !
   DEALLOCATE(phid, phid_lr, zeu, nc)
   !
   IF (.NOT. xmldyn) THEN
@@ -390,14 +532,14 @@ SUBROUTINE do_q2r(fildyn_, flfrc, prefix, zasr, la2F, loto_2d, write_lr)
      IF (ierr /= 0) CALL errore('do_q2r', 'Error deallocating phiq_lr', 1)
   END IF
   !
-  IF(la2F) CALL gammaq2r ( nfile, nat, nr1, nr2, nr3, at )
+  IF(la2F) CALL gammaq2r ( nfile, nat, nr1, nr2, nr3, at, tau )
   !
   DEALLOCATE (tau, ityp)
   !
 END SUBROUTINE do_q2r
 !
 !----------------------------------------------------------------------------
-SUBROUTINE gammaq2r( nqtot, nat, nr1, nr2, nr3, at )
+SUBROUTINE gammaq2r( nqtot, nat, nr1, nr2, nr3, at, tau )
   !----------------------------------------------------------------------------
   !
   USE kinds,      ONLY : DP
@@ -407,10 +549,13 @@ SUBROUTINE gammaq2r( nqtot, nat, nr1, nr2, nr3, at )
   USE mp,         ONLY : mp_bcast
   USE mp_world,   ONLY : world_comm
   USE el_phon,    ONLY : el_ph_nsigma
+  USE elph_tetra_mod, ONLY : lshift_q
+  USE half_q_shift, ONLY : q_shift_phase
   !
   IMPLICIT NONE
-  INTEGER, INTENT(IN) :: nqtot, nat, nr1, nr2, nr3
-  REAL(DP), INTENT(IN) :: at(3,3)
+  INTEGER, INTENT(IN) :: nqtot, nat
+  INTEGER,INTENT(INOUT) :: nr1, nr2, nr3
+  REAL(DP), INTENT(IN) :: at(3,3), tau(3, nat)
   !
   INTEGER, ALLOCATABLE :: nc(:,:,:)
   COMPLEX(DP), ALLOCATABLE :: gaminp(:,:,:,:,:), gamout(:,:,:,:,:)
@@ -475,13 +620,20 @@ SUBROUTINE gammaq2r( nqtot, nat, nr1, nr2, nr3, at )
               do icar=1,3
                  xq = xq + at(icar,ipol) * q(icar,nq) * nr(ipol)
               end do
+              IF(lshift_q) xq = xq - 0.5_dp
               lq = lq .AND. (ABS(NINT(xq) - xq) < eps)
               iq = NINT(xq)
               !
               m(ipol)= mod(iq,nr(ipol)) + 1
               if (m(ipol) < 1) m(ipol) = m(ipol) + nr(ipol)
            end do !ipol
-           IF (.NOT.lq) CALL errore('gammaq2r','q not allowed',1)
+           IF (.NOT.lq) THEN
+              IF(lshift_q) THEN
+                 CYCLE
+              ELSE
+                 IF (.NOT.lq) CALL errore('gammaq2r','q not allowed',1)
+              END IF
+           END IF
            !
            if(nc(m(1),m(2),m(3)) == 0) then
               nc(m(1),m(2),m(3)) = 1
@@ -512,6 +664,8 @@ SUBROUTINE gammaq2r( nqtot, nat, nr1, nr2, nr3, at )
      end do
      gamout = gamout / DBLE (nr1*nr2*nr3)
      !
+     IF(lshift_q) CALL q_shift_phase(nr1,nr2,nr3,nat,at,tau,gamout)
+     !
      IF (ionode) close(filea2F)
      !
      filea2F = 60 + isig
@@ -552,6 +706,14 @@ SUBROUTINE gammaq2r( nqtot, nat, nr1, nr2, nr3, at )
         WRITE (stdout,"(/5x,' fft-check success (sum of imaginary terms < 10^-12)')")
      END IF
 
+     IF(lshift_q) THEN
+        DEALLOCATE(gamout)
+        nr1 = nr(1)
+        nr2 = nr(2)
+        nr3 = nr(3)
+        ALLOCATE(gamout(nr1*nr2*nr3,3,3,nat,nat))
+     END IF
+
   ENDDO
   !
   DEALLOCATE (gaminp, gamout )
diff --git a/PHonon/PH/elph_scdft_mod.f90 b/PHonon/PH/elph_scdft_mod.f90
index ff021857b..be5cd7c16 100644
--- a/PHonon/PH/elph_scdft_mod.f90
+++ b/PHonon/PH/elph_scdft_mod.f90
@@ -28,42 +28,25 @@ SUBROUTINE elph_scdft()
   !! expand that to whole BZ.
   !
   USE kinds, ONLY : dp
-  USE parameters,  ONLY : npk
-  USE mp, ONLY : mp_sum
-  USE mp_images, ONLY : nproc_image, intra_image_comm, me_image
-  USE mp_pools, ONLY : npool, inter_pool_comm, my_pool_id, &
-  &                    nproc_pool, intra_pool_comm, me_pool
+  USE mp_pools, ONLY : npool, inter_pool_comm, my_pool_id
+  USE mp_images, ONLY : me_image
   USE io_global,   ONLY : stdout
-  USE cell_base, ONLY : at, bg
+  USE cell_base, ONLY : at
   USE ions_base, ONLY : nat
-  USE symm_base, ONLY : s, irt
-  USE klist,  ONLY: nks, nkstot, xk
-  USE noncollin_module, ONLY: nspin_lsda
   USE start_k, ONLY: nk1, nk2, nk3
-  USE wvfct, ONLY: nbnd, et
   USE qpoint, ONLY : xq, nksq
   USE dynmat, ONLY : dyn, w2
   USE el_phon, ONLY : el_ph_mat, elph_nbnd_min, elph_nbnd_max
-  USE control_lr,  ONLY : lgamma
   USE control_ph, ONLY : current_iq
   USE modes, ONLY : u
-  USE lr_symm_base, ONLY : minus_q, nsymq, rtau
-  !
-  INTEGER :: ik, ik2, ikk, ikq, ib, jb, ii, jj, isym, nu, jsym, elph_unit, &
-  &          nn, nn2, nks_real, ikv2(3), nsymqbz, nksq2, nrcv, ipe
-  INTEGER :: &
-  & nbnd_fs,  & ! = elph_nbnd_max - elph_nbnd_min + 1
-  & nkBZ        ! = nk1 * nk2 * nk3
-  !
-  REAL(dp) :: kv1(3), kv2(3)
-  REAL(dp) :: xk_col(3,nkstot)
-  COMPLEX(dp) :: epmat(3 * nat, 3 * nat)
-  !
-  INTEGER,ALLOCATABLE :: symq(:,:,:), eqBZ(:), sBZ(:), indx(:), cnt(:), dsp(:)
-  REAL(dp),ALLOCATABLE :: gg_col(:,:), gg(:,:,:,:)
+  USE noncollin_module, ONLY : nspin_lsda
+  USE io_files, ONLY : prefix, tmp_dir
   !
-  CHARACTER(100) :: chiq, elphname
+  INTEGER :: ik, ib, jb, ii, elph_unit, nrcv
+  INTEGER :: nbnd_fs
   !
+  COMPLEX(dp),ALLOCATABLE :: gep_col(:,:,:), gep(:,:,:,:)
+  CHARACTER(100) :: elphname
   INTEGER, EXTERNAL :: find_free_unit
   !
   WRITE(stdout,*) "[elph_scdft]  write elph.dat with symmetries (only on Fermi surfaces)"
@@ -74,173 +57,49 @@ SUBROUTINE elph_scdft()
   WRITE(stdout,*) "[elph_scdft]  Highest band which contains FS : ", elph_nbnd_max
   WRITE(stdout,*) "[elph_scdft]    # of bands which contains FS : ", nbnd_fs
   !
-  ! Symmetries of this q
-  !
-  nsymqbz = nsymq
-  IF(minus_q) nsymqbz = nsymq * 2
-  !
-  ALLOCATE(symq(3,3,nsymqbz))
-  !
-  symq(1:3,1:3,1:nsymq) = s(1:3,1:3,1:nsymq)
-  IF(minus_q) symq(1:3,1:3,nsymq+1:nsymq+nsymq) = - s(1:3,1:3,1:nsymq)
-  !
-  WRITE(stdout,*) "[elph_scdft]  # of symmetries of this q : ", nsymqbz
-  !
-  ! Find which k-points of a uniform grid are in the IBZ
-  !
-  CALL elph_scdft_cnt_and_dsp(inter_pool_comm,npool,my_pool_id,nks,cnt,dsp)
-  !
-  xk_col(1:3,1:nkstot) = 0_dp
-  xk_col(1:3,dsp(my_pool_id) + 1: dsp(my_pool_id) + nks) = xk(1:3,1:nks)
-  CALL mp_sum(xk_col, inter_pool_comm)
-  !
-  nkBZ = nk1 * nk2 * nk3
-  nks_real = nkstot / nspin_lsda
-  ALLOCATE(eqBZ(nkBZ), sBZ(nkBZ), indx(nkBZ))
-  !
-  IF(lgamma)THEN
-     CALL lint (nsymq, s, minus_q, at, bg, npk, 0, 0, 0, &
-     &          nk1, nk2, nk3, nks_real, xk_col, 1, nkBZ, eqBZ, sBZ)
-  ELSE
-     CALL lint (nsymq, s, minus_q, at, bg, npk, 0, 0, 0, &
-     &          nk1, nk2, nk3, nks_real, xk_col, 2, nkBZ, eqBZ, sBZ)
-  END IF
-  !
-  ! Querry of El-Ph matrix
-  !
-  nksq2 = nksq / nproc_pool
-  IF(me_pool < MOD(nksq, nproc_pool)) nksq2 = nksq2 + 1
-  !  
-  CALL elph_scdft_cnt_and_dsp(intra_pool_comm,nproc_pool,me_pool,nksq2,cnt,dsp)
-  !
-  indx(1:nkBZ) = 0
-  nksq2 = 0
-  DO ik = dsp(me_pool) + 1, dsp(me_pool) + cnt(me_pool)
-     !
-     IF(lgamma) THEN
-        ikk = ik
-     ELSE
-        ikk = 2 * ik - 1
-     END IF
-     !
-     kv1(1:3) = MATMUL(xk(1:3,ikk), at(1:3, 1:3))
-     !
-     DO isym = 1, nsymqbz
-        !
-        kv2(1:3) = MATMUL(REAL(symq(1:3,1:3,isym), dp), kv1(1:3)) * REAL((/nk1, nk2, nk3/), dp)
-        ikv2(1:3) = NINT(kv2(1:3))
-        !
-        IF(ANY(ABS(kv2(1:3) - REAL(ikv2(1:3), dp)) > 1e-5_dp)) CYCLE
-        !
-        ikv2(1:3) = MODULO(ikv2(1:3), (/nk1, nk2, nk3/))
-        nn2 = 1 + ikv2(1) + nk1 * ikv2(2) + nk1 * nk2 * ikv2(3)
-        !
-        IF(indx(nn2) /= 0) CYCLE
-        !
-        nksq2 = nksq2 + 1
-        indx(nn2) = nksq2
-        !
-     END DO
-     !
-  END DO
-  !
-  ! Collect El-Ph matrix -> PE0
+  ! Compute g in each pool
   !
-  ALLOCATE(gg(3 * nat, nbnd_fs, nbnd_fs, nksq2))
+  ALLOCATE(gep(3*nat, elph_nbnd_min:elph_nbnd_max, elph_nbnd_min:elph_nbnd_max, nksq))
   !
-  gg(1:3 * nat, 1:nbnd_fs, 1:nbnd_fs, 1:nksq2) = 0_dp
+  gep(1:3 * nat, elph_nbnd_min:elph_nbnd_max, elph_nbnd_min:elph_nbnd_max, 1:nksq) = 0.0_dp
   !
-  nksq2 = 0
-  indx(1:nkBZ) = 0
-  DO ik = dsp(me_pool) + 1, dsp(me_pool) + cnt(me_pool)
+  DO ik = 1, nksq
      !
-     IF(lgamma) THEN
-        ikk = ik
-     ELSE
-        ikk = 2 * ik - 1
-     END IF
-     !
-     kv1(1:3) = MATMUL(xk(1:3,ikk), at(1:3, 1:3))
-     !
-     DO isym = 1, nsymqbz
-        !
-        kv2(1:3) = MATMUL(REAL(symq(1:3,1:3,isym), dp), kv1(1:3)) * REAL((/nk1, nk2, nk3/), dp)
-        ikv2(1:3) = NINT(kv2(1:3))
-        !
-        IF(ANY(ABS(kv2(1:3) - REAL(ikv2(1:3), dp)) > 1e-5_dp)) CYCLE
-        !
-        ikv2(1:3) = MODULO(ikv2(1:3), (/nk1, nk2, nk3/))
-        nn  = ikv2(3) + ikv2(2) * nk3 + ikv2(1) * nk2 * nk3 + 1
-        nn2 = ikv2(1) + ikv2(2) * nk1 + ikv2(3) * nk2 * nk1 + 1
-        !
-        IF(indx(nn2) /= 0) CYCLE
-        !
-        jsym = sBZ(nn)
-        nksq2 = nksq2 + 1
-        indx(nn2) = nksq2
-        !
-        DO ib = 1, nbnd_fs
-           DO jb = 1, nbnd_fs
-              !
-              DO ii = 1, 3 * nat
-                 DO jj = 1, 3 * nat
-                    epmat(ii,jj) = CONJG(el_ph_mat(elph_nbnd_min - 1 + jb,elph_nbnd_min - 1 + ib,ik,ii)) &
-                    &                  * el_ph_mat(elph_nbnd_min - 1 + jb,elph_nbnd_min - 1 + ib,ik,jj)
-                 END DO
-              END DO
-              !
-              CALL symm(epmat, u, xq, s, jsym, rtau, irt, at, bg, nat)
-              !
-              epmat(1:3 * nat,1:3 * nat) = MATMUL(epmat(1:3 * nat,1:3 * nat), dyn(1:3 * nat,1:3 * nat))
-              !
-              DO nu = 1, 3 * nat
-                 !
-                 gg(nu,jb,ib,nksq2) = REAL(DOT_PRODUCT(dyn(1:3 * nat, nu), epmat(1:3 * nat, nu)), dp)
-                 !
-              END DO ! nu
-              !
-           END DO ! jb
-        END DO ! ib
-        !
-     END DO ! isym
+     DO ib = elph_nbnd_min, elph_nbnd_max
+        DO jb = elph_nbnd_min, elph_nbnd_max
+           !
+           DO ii = 1, 3*nat
+              gep(ii,jb,ib,ik) = DOT_PRODUCT(u(ii,1:3*nat), el_ph_mat(jb,ib,ik,1:3*nat))
+           END DO
+           gep(1:3*nat,jb,ib,ik) = MATMUL(gep(1:3*nat,jb,ib,ik), dyn(1:3 * nat,1:3 * nat))
+           !
+        END DO ! jb
+     END DO ! ib
      !
   END DO ! ik
   !
-  DO nu = 1, 3 * nat
-     IF(w2(nu) <= 0_dp) THEN
-        gg(nu, 1:nbnd_fs, 1:nbnd_fs, 1:nksq2) = 0_dp
+  DO ii = 1, 3 * nat
+     IF(w2(ii) <= 0_dp) THEN
+        gep(ii, elph_nbnd_min:elph_nbnd_max, elph_nbnd_min:elph_nbnd_max, 1:nksq) = 0_dp
      ELSE
-        gg(nu, 1:nbnd_fs, 1:nbnd_fs, 1:nksq2) = gg(nu,1:nbnd_fs,1:nbnd_fs,1:nksq2) &
-        &                                  / SQRT(w2(nu)) * 0.5_dp
+        gep(    ii, elph_nbnd_min:elph_nbnd_max, elph_nbnd_min:elph_nbnd_max,1:nksq) &
+        & = gep(ii, elph_nbnd_min:elph_nbnd_max, elph_nbnd_min:elph_nbnd_max,1:nksq) &
+        &                                  / SQRT(SQRT(w2(ii)) * 2.0_dp)
      END IF
   END DO
   !
-  ! indices of k; ik is at indx(ik)
-  !
-  CALL elph_scdft_cnt_and_dsp(intra_image_comm,nproc_image,me_image,nksq2,cnt,dsp)
-  !
-  DO ik = 1, nkBZ
-     IF(indx(ik) /= 0) indx(ik) = indx(ik) + dsp(me_image)
-  END DO
-  !
-  CALL mp_sum(indx, intra_image_comm)
-  !
   ! Gather El-Ph matrix inter pool
   !
-  IF(me_image == 0) THEN
-     nrcv = 3 * nat * nbnd_fs * nbnd_fs * nkBZ
-     ALLOCATE(gg_col(3 * nat * nbnd_fs * nbnd_fs, nkBZ))
+  IF(my_pool_id == 0) THEN
+     nrcv = 3 * nat * nbnd_fs * nbnd_fs * nk1*nk2*nk3 * nspin_lsda
+     ALLOCATE(gep_col(3*nat*nbnd_fs*nbnd_fs, nk1*nk2*nk3, nspin_lsda))
   ELSE
      nrcv = 1
-     ALLOCATE(gg_col(1,1))
+     ALLOCATE(gep_col(1,1,1))
   END IF
   !
-  CALL elph_scdft_gather_r(gg,3 * nat * nbnd_fs * nbnd_fs * nksq2,gg_col,nrcv, &
-  &                me_image, nproc_image, intra_image_comm)
-  !
-  CALL mp_sum(nksq2, intra_image_comm)
-  !
-  WRITE(stdout,*) "Verify SUM(nksq2), nkBZ : ", nksq2, nkBZ
+  CALL elph_scdft_gather(gep, 3*nat*nbnd_fs*nbnd_fs*nksq, gep_col, nrcv, &
+  &                      my_pool_id, npool, inter_pool_comm)
   !
   ! Write el-ph to file elph.dat
   !
@@ -248,8 +107,7 @@ SUBROUTINE elph_scdft()
      !
      elph_unit = find_free_unit()
      !
-     WRITE(chiq,*) current_iq
-     WRITE(elphname,'(a,a,a)') "elph", TRIM(ADJUSTL(chiq)), ".dat"
+     WRITE(elphname,'(3a,i0)') TRIM(tmp_dir), TRIM(prefix), ".elph", current_iq
      !
      OPEN(elph_unit,file = TRIM(elphname))
      !
@@ -259,72 +117,38 @@ SUBROUTINE elph_scdft()
      ! 
      !# of band
      !
-     WRITE(elph_unit,*) nbnd_fs, elph_nbnd_min
+     WRITE(elph_unit,*) elph_nbnd_min, elph_nbnd_max
      !
      ! q-vector(Crystal cordinate)
      !
      WRITE(elph_unit,*) MATMUL(xq(1:3), at(1:3, 1:3))
      !
-     !# of mode
+     ! # of mode
      !
      WRITE(elph_unit,*) 3 * nat
      !
      ! Frequences[Ryd]
      !
      DO ii = 1, 3 * nat
-        WRITE(elph_unit,*) SQRT(ABS(w2(ii)))
+        WRITE(elph_unit,*) SIGN(SQRT(ABS(w2(ii))), w2(ii))
      END DO
      WRITE(elph_unit,*) ""
      !
      ! Electron-Phonon matrix
      !
-     DO ik = 1, nkBZ
-        WRITE(elph_unit,'(3e25.15)') gg_col(1:3 * nat * nbnd_fs * nbnd_fs, indx(ik))
-     END DO
+     WRITE(elph_unit,'(6e25.15)') &
+     &  gep_col(1:3*nat*nbnd_fs*nbnd_fs, 1:nk1*nk2*nk3, 1:nspin_lsda)
      !
      CLOSE(elph_unit)
      !
   END IF ! IF(ionode)
   !
-  DEALLOCATE(sBZ, eqBZ, gg, gg_col)
-  !
-  DEALLOCATE(symq, cnt, dsp)
-  !
-  CALL elph_scdft_dmuxc()
+  DEALLOCATE(gep, gep_col)
   !
 END SUBROUTINE elph_scdft
 !
-!----------------------------------------------------------
-SUBROUTINE elph_scdft_cnt_and_dsp(comm,npe,mype,nn,cnt,dsp)
-  !--------------------------------------------------------
-  !! This routine computes coutnt and disples for MPI.
-  ! Communicater : comm
-  !
-  USE mp, ONLY : mp_sum
-  !
-  INTEGER,INTENT(IN) :: npe, mype, comm, nn
-  INTEGER,INTENT(OUT),ALLOCATABLE :: cnt(:), dsp(:)
-  !
-  INTEGER :: ipe
-  !
-  IF(ALLOCATED(cnt)) DEALLOCATE(cnt)
-  IF(ALLOCATED(dsp)) DEALLOCATE(dsp)
-  !
-  ALLOCATE(cnt(0:npe-1), dsp(0:npe-1))
-  !
-  cnt(0:npe - 1) = 0
-  cnt(mype) = nn
-  CALL mp_sum(cnt, comm)
-  !
-  dsp(0) = 0
-  DO ipe = 1, npe - 1
-     dsp(ipe) = dsp(ipe - 1) + cnt(ipe - 1)
-  END DO
-  !
-END SUBROUTINE elph_scdft_cnt_and_dsp
-!
 !------------------------------------------------------------------------
-SUBROUTINE elph_scdft_gather_r(snd,nsnd,rcv,nrcv,mype,npe,comm)
+SUBROUTINE elph_scdft_gather(snd,nsnd,rcv,nrcv,mype,npe,comm)
   !----------------------------------------------------------------------
   !! This routine gathers a real matrix to PE 0.
   !
@@ -332,8 +156,8 @@ SUBROUTINE elph_scdft_gather_r(snd,nsnd,rcv,nrcv,mype,npe,comm)
   USE mp, ONLY : mp_sum, mp_gather
   !
   INTEGER,INTENT(IN) :: nsnd, nrcv, mype, npe, comm
-  REAL(dp),INTENT(IN) :: snd(nsnd)
-  REAL(dp),INTENT(OUT) :: rcv(nrcv)
+  COMPLEX(dp),INTENT(IN) :: snd(nsnd)
+  COMPLEX(dp),INTENT(OUT) :: rcv(nrcv)
   !
   INTEGER :: cnt(0:npe - 1), dsp(0:npe - 1), ipe
   !
@@ -349,112 +173,6 @@ SUBROUTINE elph_scdft_gather_r(snd,nsnd,rcv,nrcv,mype,npe,comm)
   !
   CALL mp_gather(snd(1:nsnd), rcv(1:nrcv), cnt, dsp, 0, comm)
   !
-END SUBROUTINE elph_scdft_gather_r
-!
-!--------------------------------------------------------
-SUBROUTINE elph_scdft_dmuxc()
-  !------------------------------------------------------
-  !! This routine outputs the \(f_{XC}\) for LDA in G space
-  !! to a file.
-  !
-  USE mp,        ONLY : mp_sum, mp_max, mp_min
-  USE kinds,     ONLY : dp
-  USE gvect,     ONLY : mill
-  USE wvfct,     ONLY : npwx
-  USE klist,     ONLY : ngk, igk_k
-  USE fft_base,  ONLY : dffts
-  USE mp_images, ONLY : me_image
-  USE mp_pools,  ONLY : intra_pool_comm
-  USE eqv,       ONLY : dmuxc
-  !
-  INTEGER :: gmin(3), gmax(3), ig, dmxc_unit
-  COMPLEX(dp) :: dmxc1(dffts%nnr), dmxc2(npwx)
-  COMPLEX(dp),ALLOCATABLE :: dmxc3(:,:,:)
-  !
-  INTEGER, EXTERNAL :: find_free_unit
-  !
-  ! Define whole G-grid
-  !
-  gmin(1:3) =   100
-  gmax(1:3) = - 100
-  DO ig = 1, ngk(1)
-     gmax(1:3) = max(gmax(1:3), mill(1:3, igk_k(ig,1)))
-     gmin(1:3) = min(gmin(1:3), mill(1:3, igk_K(ig,1)))
-  END DO
-  !
-  ! FW_FFT dmuxc_r -> dmuxc_G
-  !
-  dmxc1(1:dffts%nnr) = cmplx(dmuxc(1:dffts%nnr,1,1), 0_dp)
-  CALL elph_scdft_fft(dmxc2(1:npwx), dmxc1(1:dffts%nnr),  ngk(1),  igk_k(:,1),  -1)
-  !
-  CALL mp_max(gmax, intra_pool_comm)
-  CALL mp_min(gmin, intra_pool_comm)
-  !
-  ALLOCATE(dmxc3(gmin(1):gmax(1), gmin(2):gmax(2), gmin(3):gmax(3)))
-  !
-  dmxc3(gmin(1):gmax(1),gmin(2):gmax(2),gmin(3):gmax(3)) = cmplx(0_dp,0_dp)
-  DO ig = 1, ngk(1)
-     dmxc3(mill(1,igk_k(ig,1)), mill(2,igk_k(ig,1)), mill(3,igk_k(ig,1))) = dmxc2(ig)
-  END DO
-  !
-  CALL mp_sum(dmxc3, intra_pool_comm)
-  !
-  IF(me_image == 0) THEN
-     !
-     dmxc_unit = find_free_unit()
-     !
-     OPEN(dmxc_unit, file = "dmuxc.dat")
-     !
-     WRITE(dmxc_unit,*) gmin(1:3)
-     WRITE(dmxc_unit,*) gmax(1:3)
-     !
-     WRITE(dmxc_unit,*) ""
-     WRITE(dmxc_unit,'(2e25.15)') dmxc3(gmin(1):gmax(1),gmin(2):gmax(2),gmin(3):gmax(3))
-     !
-     CLOSE(dmxc_unit)
-     !
-  END IF
-  !
-  DEALLOCATE(dmxc3)
-  !
-END SUBROUTINE elph_scdft_dmuxc
-!
-!--------------------------------------------------------------------
-SUBROUTINE elph_scdft_fft(evc_g, evc_r, npw, igk, isw)
-  !------------------------------------------------------------------
-  !! This routine performs inverse-FFT for \(f_{XC}\).
-  !
-  USE kinds, ONLY : dp
-  USE wvfct, ONLY : npwx
-  USE fft_base,   ONLY: dffts
-  USE fft_interfaces, ONLY: fwfft, invfft
-  !
-  INTEGER,INTENT(IN) :: isw
-  INTEGER,INTENT(IN) :: npw, igk(npw)
-  COMPLEX(dp),INTENT(INOUT) :: evc_g(npwx), evc_r(dffts%nnr)
-  !
-  INTEGER :: ig
-  !
-  IF (isw.eq.1) THEN
-     !
-     evc_r = (0_dp, 0_dp)
-     !     
-     DO ig = 1, npw
-        evc_r(dffts%nl(igk(ig))) = evc_g(ig)
-     END DO
-     !
-     CALL invfft ('Wave', evc_r(1:dffts%nnr), dffts)
-     !
-  ELSE IF(isw.eq.-1) THEN
-     !
-     CALL fwfft ('Wave', evc_r(1:dffts%nnr), dffts)
-     !
-     DO ig = 1, npw
-        evc_g(ig) = evc_r(dffts%nl(igk(ig)))
-     END DO
-     !
-  END IF
-  !
-END SUBROUTINE elph_scdft_fft
+END SUBROUTINE elph_scdft_gather
 !
 END MODULE elph_scdft_mod
diff --git a/PHonon/PH/elph_tetra_mod.f90 b/PHonon/PH/elph_tetra_mod.f90
index 285031d11..202f846e1 100644
--- a/PHonon/PH/elph_tetra_mod.f90
+++ b/PHonon/PH/elph_tetra_mod.f90
@@ -23,7 +23,7 @@ MODULE elph_tetra_mod
   INTEGER,SAVE :: elph_tetra = 0 ! switch to output electron-phonon matrix
   !
   PUBLIC elph_tetra, lshift_q, in_alpha2f, &
-  &      elph_tetra_lambda, elph_tetra_gamma
+  &      elph_tetra_lambda, elph_tetra_gamma, elph_tetra_delta1
   !
   CONTAINS
  !
diff --git a/PHonon/PH/q2r.f90 b/PHonon/PH/q2r.f90
index 04d884de6..ae77f5d44 100644
--- a/PHonon/PH/q2r.f90
+++ b/PHonon/PH/q2r.f90
@@ -28,6 +28,7 @@ PROGRAM q2r
   USE mp_global,   ONLY : mp_startup, mp_global_end
   USE io_global,   ONLY : ionode_id, ionode, stdout
   USE environment, ONLY : environment_start, environment_end
+  USE elph_tetra_mod, ONLY : lshift_q
   USE el_phon,     ONLY : el_ph_nsigma
   !
   IMPLICIT NONE
@@ -75,7 +76,7 @@ PROGRAM q2r
   !! asr='all' for polar solids in matdyn.
   INTEGER :: ios
   !
-  NAMELIST / input / fildyn, flfrc, prefix, zasr, la2F, loto_2d, write_lr, el_ph_nsigma
+  NAMELIST / input / fildyn, flfrc, prefix, zasr, la2F, loto_2d, write_lr, el_ph_nsigma, lshift_q
   !
   CALL mp_startup()
   CALL environment_start('Q2R')
@@ -91,6 +92,7 @@ PROGRAM q2r
      !
   la2F=.false.
   el_ph_nsigma=10
+  lshift_q = .false.
      !
      !
   IF (ionode)  READ ( 5, input, IOSTAT =ios )
@@ -104,6 +106,7 @@ PROGRAM q2r
   CALL mp_bcast(zasr, ionode_id, world_comm)
   CALL mp_bcast(loto_2d, ionode_id, world_comm)
   CALL mp_bcast(la2F, ionode_id, world_comm)
+  CALL mp_bcast(lshift_q, ionode_id, world_comm)
   CALL mp_bcast(el_ph_nsigma, ionode_id, world_comm)
   CALL mp_bcast(write_lr, ionode_id, world_comm)
   !
diff --git a/PHonon/PH/run_nscf.f90 b/PHonon/PH/run_nscf.f90
index c9952de52..eeaba61db 100644
--- a/PHonon/PH/run_nscf.f90
+++ b/PHonon/PH/run_nscf.f90
@@ -41,6 +41,7 @@ SUBROUTINE run_nscf(do_band, iq)
   USE noncollin_module,ONLY : noncolin, domag
   USE klist,           ONLY : qnorm, nelec
   USE el_phon,         ONLY : elph_mat
+  USE elph_tetra_mod,  ONLY : elph_tetra
   USE ahc,             ONLY : elph_ahc
   USE mp_images,       ONLY : intra_image_comm
   USE mp,              ONLY : mp_barrier
@@ -104,7 +105,7 @@ SUBROUTINE run_nscf(do_band, iq)
   CALL fft_type_allocate ( dfftp, at, bg, gcutm,  intra_bgrp_comm, nyfft=nyfft )
   CALL fft_type_allocate ( dffts, at, bg, gcutms, intra_bgrp_comm, nyfft=nyfft)
   !
-  CALL setup_nscf ( newgrid, xq, elph_mat .OR. elph_ahc )
+  CALL setup_nscf ( newgrid, xq, elph_mat .OR. elph_ahc .OR. (elph_tetra == 3) )
   !
   !
   if (twochem) occupations ='smearing' !this is needed to avoid init_twochem error check.
diff --git a/PHonon/examples/tetra_example/run_example b/PHonon/examples/tetra_example/run_example
index 852dc2652..e45f11497 100755
--- a/PHonon/examples/tetra_example/run_example
+++ b/PHonon/examples/tetra_example/run_example
@@ -78,6 +78,8 @@ $ECHO " done"
 # how to run executables
 PW_COMMAND="$PARA_PREFIX $BIN_DIR/pw.x $PARA_POSTFIX"
 PH_COMMAND="$PARA_PREFIX $BIN_DIR/ph.x $PARA_POSTFIX"
+Q2R_COMMAND="$PARA_PREFIX $BIN_DIR/q2r.x $PARA_POSTFIX"
+MATDYN_COMMAND="$PARA_PREFIX $BIN_DIR/matdyn.x $PARA_POSTFIX"
 ALPHA2F_COMMAND="$PARA_PREFIX $BIN_DIR/alpha2f.x"
 $ECHO
 $ECHO "  running pw.x as: $PW_COMMAND"
@@ -175,6 +177,81 @@ $PH_COMMAND -in al.elph.in > al.elph.out
 check_failure $?
 $ECHO "  done"
 #
+#   q2r and matdyn
+#
+cat > al.q2r.in << EOF
+&INPUT
+   fildyn = 'al.dyn'
+     la2f = .true.
+ lshift_q = .true.
+     zasr = 'crystal'
+    flfrc = 'Al444.fc'
+/
+EOF
+$ECHO "  running q2r...\c"
+$Q2R_COMMAND < al.q2r.in > al.q2r.out
+check_failure $?
+$ECHO "  done"
+#
+#
+#
+cat > matdyn.in.freq << EOF
+ &input
+      asr = 'crystal',
+ amass(1) = 26.98,
+    flfrc = 'Al444.fc',
+    flfrq = 'Al444.freq',
+     la2F = .true.,
+      dos = .false.
+ /
+  19
+  0.000 0.0 0.0     0.0
+  0.125 0.0 0.0     0.0
+  0.250 0.0 0.0     0.0
+  0.375 0.0 0.0     0.0
+  0.500 0.0 0.0     0.0
+  0.750 0.0 0.0     0.0
+  1.000 0.0 0.0     0.0
+  0.825 0.125 0.125 0.0
+  0.750 0.250 0.250 0.0
+  0.625 0.375 0.375 0.0
+  0.500 0.500 0.500 0.0
+  0.325 0.325 0.325 0.0
+  0.250 0.250 0.250 0.0
+  0.125 0.125 0.125 0.0
+  0.000 0.000 0.000 0.0
+  0.125 0.125 0.000 0.0
+  0.250 0.250 0.000 0.0
+  0.325 0.325 0.000 0.0
+  0.500 0.500 0.000 0.0
+EOF
+$ECHO "  running matdyn for frequency calculation...\c"
+$MATDYN_COMMAND < matdyn.in.freq > matdyn.out.freq
+check_failure $?
+$ECHO "  done"
+#
+#
+#
+cat > matdyn.in.dos << EOF
+ &input
+       asr = 'crystal',
+  amass(1) = 26.98,
+     flfrc = 'Al444.fc',
+     flfrq = 'Al444.freq',
+      la2F = .true.,
+       dos = .true.
+     fldos = 'phonon.dos',
+       nk1 = 16,
+       nk2 = 16,
+       nk3 = 16,
+      ndos = 100
+ /
+EOF
+$ECHO "  running matdyn for a2F(omega) calculation...\c"
+$MATDYN_COMMAND < matdyn.in.dos > matdyn.out.dos
+check_failure $?
+$ECHO "  done"
+#
 # Eliashberg function
 #
 $ECHO "  running alpha2f.x for lambda and a2F calculation...\c"
diff --git a/install/makedeps.sh b/install/makedeps.sh
index 9682d939b..2ad354f63 100755
--- a/install/makedeps.sh
+++ b/install/makedeps.sh
@@ -24,6 +24,7 @@ then
            upflib XClib Modules LR_Modules PW/src CPV/src PW/tools PP/src PWCOND/src \
            PHonon/Gamma PHonon/PH PHonon/FD HP/src atomic/src \
            EPW/src EPW/ZG/src XSpectra/src NEB/src TDDFPT/src \
+           SCTK/src \
            GWW/pw4gww GWW/gww GWW/head GWW/bse GWW/simple \
 	   GWW/simple_bse GWW/simple_ip QEHeat/src KCW/src KCW/PP "
           
@@ -110,6 +111,8 @@ for dir in $dirs; do
 	     DEPENDS="$DEPEND2 $LEVEL2/GWW/gww" ;;
 	GWW/simple_ip)
 	     DEPENDS="$DEPEND2" ;;
+	SCTK/src )
+	     DEPENDS="$DEPEND2 $LEVEL2/PW/src $LEVEL2/PHonon/PH $LEVEL2/LR_Modules $LEVEL2/PP/src" ;;	
     *)
 # if addson needs a make.depend file
 	DEPENDS="$DEPENDS $add_deps"
